<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Hello Rxjs!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/7.8.1/rxjs.umd.min.js"></script>
</head>

<body>
    <script type="text/javascript">
        const { Subject, of, throwError, timer, switchMap, takeUntil } = rxjs;

        function mockApiRequest() {
            return new Promise((resolve, reject) => {
                const isSuccess = Math.random() > 0.7;

                setTimeout(() => {
                    if (isSuccess) {
                        resolve({ code: '0000', data: Math.random() });
                    } else {
                        reject({ code: '0001', error: '请求失败' });
                    }
                }, 1000);
            });
        }

        const stopPolling$ = new Subject();

        function startPolling(apiFunc, maxRetries = 10, initialDelay = 2000) {
            let retries = 0;
            let delay = initialDelay;

            const attemptRequest = () => {
                return apiFunc().then(data => {
                    stopPolling$.next(data); // 成功则停止
                    console.log(`请求成功，停止轮询, 返回数据: ${JSON.stringify(data, null, 2)}`);
                    return data; // 返回成功的数据
                }).catch(err => {
                    retries++;
                    console.log(`第${retries}次重试失败`, err);
                    if (retries >= maxRetries) {
                        return throwError(new Error('重试次数已达上限')); // 抛出错误
                    }
                    delay = Math.min(delay + 1000, 10000); // 每次失败后延长延迟
                    console.log(`正在进行第${retries + 1}次重试，延迟${delay / 1000}秒...`);
                    return timer(delay).pipe(
                        switchMap(() => attemptRequest()) // 使用 RxJS 重新尝试
                    ).toPromise(); // 转换为 Promise
                });
            };

            return attemptRequest();
        }

        const initialRequest$ = of(null).pipe(
            switchMap(() => startPolling(mockApiRequest)),
            takeUntil(stopPolling$)
        );

        const subscription = initialRequest$.subscribe({
            next: data => {
                console.log('请求成功', data);
            },
            error: err => {
                console.log('请求失败', err);
            }
        });

        // 停止轮询的逻辑（例如在 30 秒后停止）
        setTimeout(() => {
            console.log('手动停止轮询...');
            stopPolling$.next(); // 发送停止信号
            subscription.unsubscribe(); // 取消订阅
        }, 30000);
    </script>
</body>

</html>
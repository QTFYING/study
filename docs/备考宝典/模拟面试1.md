# 模拟面试一

## 手写题目

手写防抖节流函数

## 面试题

### 讲一下最近的项目以及难点亮点

范式开发（模态框、form和详情统一、路由参数约束、埋点范式、table局部报错）、S3分包、菜单权限设计、react和vue的ui组件统一

### 讲一下 vue 和 react 的 区别？

可以从设计理念、模板和JSX、状态管理、组件通信、样式处理、学习曲线、生态系统、性能优化8个方面说说看

### 讲一下 闭包 优缺点

* 优点：可以封装私有变量，避免全局污染。具体有：数据封装、保持状态、工厂函数等
* 缺点：容易造成内存泄漏（闭包会一直保存对外部变量的引用）。具体有：内存泄漏风险、性能影响、调试困难等

### 为什么react useState 要用数组解构，而不是函数

主要基于以下设计考量：命名灵活性、顺序保证、简洁性、多状态场景优势

### 讲一下react 生命周期

#### class组件生命周期

* 挂载阶段：constructor（1、初始化state）、getDerivedStateFromProps（2、派生状态）、render（3、渲染UI）、componentDidMount（4、DOM就绪）
* 更新阶段：shouldComponentUpdate（1、性能优化）、getSnapshotBeforeUpdate（2、获取DOM快照）、componentDidUpdate（3、更新完成）
* 卸载阶段：componentWillUnmount（1、卸载阶段，清除定时器和一些事件监听）

#### 函数式组件生命周期

##### 挂载阶段

``` javascript
// 空依赖数组，等同于componentDidMount
useEffect(() => {
  fetchData();
}, [])
```

##### 更新阶段

``` javascript
// 依赖项变化时触发，等同于componentDidUpdate
useEffect(() => {
  fetchData();
}, [deps1, deps2])
```

##### 卸载阶段

``` javascript
// 相当于componentWillUnmount
useEffect(() => {
  return () => {
    clearTimeout(timer); // 清除定时器
  }
}, [])
```

### 讲一下 react render的全流程

render主要有三个核心阶段

#### 调度阶段

作用：确定更新任务的优先级（如用户输入 > 数据加载）

主要API有：

| 对比              | 用途 | 优先级相关 |
| ------------------| --------- |------------------------ |
| startTransition   |	标记某个状态更新为非紧急，如搜索建议    | 降低优先级         |
| useTransition     | Hook 版本的 startTransition          | 可得到更新是否 pending 的信息      |
| useDeferredValue  | 延迟某个值的更新，用于优化渲染性能      | 延迟渲染，优先级低       |
| flushSync         | 强制同步执行更新（最高优先级，慎用）    | 最高优先级    |

#### 协调阶段

作用：生成Fiber树差异（虚拟DOM比较）

#### 提交阶段

作用：将变更应用到真实DOM

### react协调算法是什么实现的，为什么需要Fiber

#### 什么是 React 的协调（Reconciliation）算法？

当组件状态（state）或属性（props）发生变化时，React 会重新调用 render 方法生成新的虚拟 DOM，然后通过“协调算法”比较新旧虚拟 DOM 树的差异（这个过程也叫 ​Diffing），最后只把必要的改动应用到真实的 DOM 上，避免整棵树重新渲染，提高性能。

#### fiber的来由

1、React在v16之前是基于 Stack 的协调算法，之后引入fiber架构，解决了Stack协调算法的两大问题：无法中断更新任务、无法确定任务优先级。
2、v16之后，引入fiber架构，也引入了与之配套的fiber协调器。

#### 原架构存在的问题

​无法中断​：如果组件树很大，一次更新可能要花费很长时间（比如几百毫秒），这就会造成 ​主线程被长时间占用，导致页面卡顿、无法响应用户输入（比如点击、滚动等），也就是 ​掉帧、不流畅的用户体验。

​缺乏优先级​：所有更新都被一视同仁，不管是用户点击按钮这样的 ​高优先级交互，还是后台数据加载这样的 ​低优先级任务，都一起排队处理，没有区分。

#### fiber是什么

##### 它既是一种数据结构，也是一种协调算法的实现机制。​

每个 React 组件在渲染时，都会对应一个 ​Fiber 节点，它本质是一个 ​JavaScript 对象，用来描述组件的一些信息，比如：
组件类型（函数组件、类组件、原生 DOM 元素）
组件的状态（state）
组件的副作用（比如 DOM 更新）
组件的子 Fiber 节点
当前 Fiber 的优先级
以及指向下一个 Fiber 节点的指针（形成链表结构）

总结：
✅ 所有的 Fiber 节点通过 child、sibling和 return属性连接成一棵 ​Fiber 树，它是 React 用来追踪组件更新和副作用的内部表示。
✅ 简单说：​Fiber 是 React 用来表示组件树中每个节点的一个轻量对象，也是调度和更新的最小单位。

##### ​Fiber 是一种协调算法 & 可中断的渲染机制​

Fiber 架构的最大革新在于，它把原来 ​递归的、不可中断的渲染过程，改造成 ​可拆分、可暂停、可恢复、可优先级调度​ 的过程。

Fiber 协调器的工作方式：
React 将渲染过程拆分成许多细小的 ​​“工作单元”（即一个个 Fiber 节点）​。
每次只处理一个 Fiber（比如一个组件），做完后可以 ​暂停，让出主线程去处理 ​高优先级任务​（比如用户点击）。
处理完高优先级任务后，再 ​恢复​ 原来的渲染工作，继续从上次暂停的地方接着处理。
这种机制使得 React 能够更灵活地调度任务，保证页面的流畅性。

总结：
✅ 这就是所谓的 ​​“可中断渲染”（Interruptible Rendering）​，也是 Fiber 架构的核心目标之一。​

#### 为啥需要fiber

* ​解决渲染过程不可中断的问题
* 支持任务优先级调度
* 为并发特性打下基础
* ​更细粒度的控制和优化

### 什么是Fiber架构，空闲渲染有了解吗

Fiber结构同上，空闲渲染也是Fiber中的一个概念，Fiber通过将不同任务划分不同的等级，然后利用调度机制将一些任务进行空闲渲染，比如：日志上报、预加载、延迟渲染、非紧急状态更新等。
